<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ray tracing in one weekend 中文翻译 - Oxine&#039;s site</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Oxine&#039;s site"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Oxine&#039;s site"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="写在前头: 2020年3月23日, 本书的全新版本上线啦, 当时笔者正好翻译完第二本书, 提issue的时候得知这个消息, 顿时心态崩了。浏览了一下develop分支下的新版本, 和旧版差异还不少。没办法, 返工吧。 本文翻译自新版本v3.0.1, 相较之前的版本, 新版本改进了许多细节, 修复了一些bug, 并对原来一些比较模糊的地方加以详细的阐释, 并使用了智能指针等c++特性。 译者水平有限"><meta property="og:type" content="blog"><meta property="og:title" content="ray tracing in one weekend 中文翻译"><meta property="og:url" content="https://matrix4f.com/Graphic/ray-tracing-in-one-weekend/"><meta property="og:site_name" content="Oxine&#039;s site"><meta property="og:description" content="写在前头: 2020年3月23日, 本书的全新版本上线啦, 当时笔者正好翻译完第二本书, 提issue的时候得知这个消息, 顿时心态崩了。浏览了一下develop分支下的新版本, 和旧版差异还不少。没办法, 返工吧。 本文翻译自新版本v3.0.1, 相较之前的版本, 新版本改进了许多细节, 修复了一些bug, 并对原来一些比较模糊的地方加以详细的阐释, 并使用了智能指针等c++特性。 译者水平有限"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://i.loli.net/2020/03/22/zfk3Q1tuLECywHO.jpg"><meta property="article:published_time" content="2020-03-03T13:07:22.000Z"><meta property="article:modified_time" content="2021-06-11T09:57:43.107Z"><meta property="article:author" content="oxine"><meta property="article:tag" content="ray tracing"><meta property="article:tag" content="graphic"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2020/03/22/zfk3Q1tuLECywHO.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://matrix4f.com/Graphic/ray-tracing-in-one-weekend/"},"headline":"ray tracing in one weekend 中文翻译","image":["https://i.loli.net/2020/03/22/zfk3Q1tuLECywHO.jpg"],"datePublished":"2020-03-03T13:07:22.000Z","dateModified":"2021-06-11T09:57:43.107Z","author":{"@type":"Person","name":"oxine"},"publisher":{"@type":"Organization","name":"Oxine's site","logo":{"@type":"ImageObject","url":"https://matrix4f.com/img/logo.svg"}},"description":"写在前头: 2020年3月23日, 本书的全新版本上线啦, 当时笔者正好翻译完第二本书, 提issue的时候得知这个消息, 顿时心态崩了。浏览了一下develop分支下的新版本, 和旧版差异还不少。没办法, 返工吧。 本文翻译自新版本v3.0.1, 相较之前的版本, 新版本改进了许多细节, 修复了一些bug, 并对原来一些比较模糊的地方加以详细的阐释, 并使用了智能指针等c++特性。 译者水平有限"}</script><link rel="canonical" href="https://matrix4f.com/Graphic/ray-tracing-in-one-weekend/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Oxine&#039;s site" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-03-03T13:07:22.000Z" title="2020/3/3 下午9:07:22">2020-03-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-06-11T09:57:43.107Z" title="2021/6/11 下午5:57:43">2021-06-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Graphic/">Graphic</a></span><span class="level-item">2 hours read (About 18407 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">ray tracing in one weekend 中文翻译</h1><div class="content"><p>写在前头:</p>
<p>2020年3月23日, 本书的全新版本上线啦, 当时笔者正好翻译完第二本书, 提issue的时候得知这个消息, 顿时心态崩了。浏览了一下develop分支下的新版本, 和旧版差异还不少。没办法, 返工吧。</p>
<p>本文翻译自新版本v3.0.1, 相较之前的版本, 新版本改进了许多细节, 修复了一些bug, 并对原来一些比较模糊的地方加以详细的阐释, 并使用了智能指针等c++特性。</p>
<p>译者水平有限, 有些地方读起来难免会感到怪怪的, 还请各位见谅。如果您遇到什么看不懂的地方或者乱七八糟的句子, 那么您很可能是辣鸡翻译的受害者, 这时候请不要犹豫, 直接去<a target="_blank" rel="noopener" href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">阅读原文</a>自救。如果您愿意帮助我改进这个翻译, 请直接在<strong>页面底部留言</strong>或<strong>发送邮件</strong>到<a href="mailto:zgxmy@126.com">zgxmy@126.com</a>, 万分感激!!!</p>
<p><a href="#overview">1. Overview 概述</a><br><a href="#outputaimage">2. Output a Image 输出你的图像</a><br><a href="#vec3">3. The vec3 Class vec3向量类</a><br><a href="#raycamerabg">4. Rays, a Simple Camera, and Background 光线, 简单摄像机, 以及背景</a><br><a href="#sphere">5. Adding a Sphere 加入球体</a><br><a href="#normalandmultobject">6. Suface Normals and Multiple Objects 面法相与多个物体</a><br><a href="#aa">7. Antialiasing 反走样</a><br><a href="#diffuse">8. Diffuse Material 漫反射材质</a><br><a href="#metal">9. Metal 金属材质</a><br><a href="#dielectric">10. Dielectric 绝缘体材质</a><br><a href="#positionablecamera">11. Positionable Camera 可自定义位置的摄像机</a><br><a href="#defocus">12. Defocus Blur 对焦模糊</a><br><a href="#next">13. Where Next? 接下来学什么?</a></p>
<span id="more"></span>
<p><a id="overview"></a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>这些年来我开过不少图形学的课。我常常把光线追踪作为课堂上的教学内容。因为对于光线追踪来说, 在不使用任何API的情况下, 你不得不被迫手撸全部的代码, 但你仍然能渲染出炫酷的图片。我决定将我的课堂笔记改写成本教程, 让你能尽可能快的实现一个炫酷的光线追踪器(ray tracer)。这并不是一个功能完备的光线追踪器。但是它却拥用让光线追踪在电影行业成为主流的非直接光照(indirect lighting)。跟随本教程循序渐进, 你的光线追踪器的代码构筑将会变得易于拓展。如果之后你对这方面燃起了兴趣, 你可以将它拓展成一个更加完备的光线追踪器。</p>
<p>当大家提起”光线追踪”, 可能指的是很多不同的东西。我对这个词的描述是, 光线追踪在技术上就是一个路径追踪器, 事实上大部分情况下这个词都是这个意思。光线追踪器的代码也是十分的简单(让电脑帮我们算去吧!)。当你看到你渲染的图片时, 你一定会感到高兴的。</p>
<p>接下来我会带你一步步的实现这个光线追踪, 并加入一些我的debug建议。最后你会得到一个能渲染出漂亮图片的光线追踪器。你认为你应该能在一个周末的时间内搞定。如果你花的时间比这长, 别担心, 也没太大问题。我使用C++作为本光线追踪器的实现语言。你其实不必, 但我还是推荐你用C++, 因为C++快速, 平台移植性好, 并且大部分的工业级电影和游戏渲染器都是使用C++编写的。注意这里我避免了大部分C++的新特性。但是继承和重载运算符我们保留, 对光线追踪器来说这个太有用了。网上的那些代码不是我提供的, 但是这些代码是真的可以跑的。除了<code>vec3</code>类中的一些简单的操作, 我将所有的代码都公开了。我是”学习编程要亲自动手敲代码”派。但是如果有一份代码摆在我面前, 我可以直接用, 我还是会用的。所以我只在没代码用的时候, 我才奉行我刚刚说的话。好啦, 别提这个了!</p>
<p>我没把上面一段删了, 因为我的态度180°大转变太好玩了。读者们帮我修复了一些次要的编译错误, 所以还是请你亲手来敲一下代码吧!但是你如果你想看看我的代码:<a target="_blank" rel="noopener" href="https://github.com/RayTracing/raytracing.github.io/">点击这里</a></p>
<p>我假定你有一定的向量知识(比如说点乘和叉乘)。如果你记不太清楚, 回顾一下就行。如果你需要回顾, 或者你是第一次听说这个东西, 你可以看我或者Marschner的图像教材, Foley, Van Dam等也行。或者McGuire的codex。</p>
<p>如果你遇到的麻烦, 或者你弄出了很cooool的东西想要分享给大家看, 请给我发邮件。我的邮箱是<a href="mailto:&#112;&#116;&#114;&#x73;&#104;&#x72;&#x6c;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#112;&#116;&#114;&#x73;&#104;&#x72;&#x6c;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a><a href="mailto:ptrshrl@gmail.com">点我发邮件</a></p>
<p>我会维护一个有关本书的博客网站, 网站里有一些拓展阅读和一些链接资源。网址是 <a target="_blank" rel="noopener" href="https://in1weekend.blogspot.com/">https://in1weekend.blogspot.com</a></p>
<p>好了不多BB, 让我们开始吧!</p>
<p><a id="outputaimage"></a></p>
<h2 id="2-输出你的图像"><a href="#2-输出你的图像" class="headerlink" title="2. 输出你的图像"></a>2. 输出你的图像</h2><p>当你开始写渲染器的时候, 你首先得能有办法看到你渲染的图像。最直接了当的方法就行把图像信息写入文件。问题是, 有那么多图片格式, 而且许多格式都挺复杂的。在开始部分, 我常常使用最简单的ppm文件。这里引用Wikipedia上面的简明介绍:</p>
<p><img src="/img/t.png"></p>
<p>我们来写一下输出这种图片格式的C++代码:</p>
<figure class="highlight c++"><figcaption><span>main.cc 创建你的第一个图像</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in"><span class="keyword">double</span></span>(i) / image_width;</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in"><span class="keyword">double</span></span>(j) / image_height;</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.2</span>;</span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">            std::cout &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码里有一些我们要注意的事情:</p>
<p>1.对于像素来说, 每一行是从左往右写入的。</p>
<p>2.行从上开始往下写入的。</p>
<p>3.通常我们把RGB通道的值限定在0.0到1.0。我们之后计算颜色值的时候将使用一个动态的范围, 这个范围并不是0到1。但是在使用这段代码输出图像之前, 我们将把颜色映射到0到1。所以这部分输出图像代码不会改变。【译注: <strong>这里挺重要的, 别忘了</strong>忘掉这个在第一本书并不会出现任何问题, 直到第二本书前大半也没问题, 但是一到cornell box与光源的引入, 事情就糟糕了, 不少人都踩进去了,详见<a target="_blank" rel="noopener" href="https://github.com/RayTracing/raytracing.github.io/issues/94">issue-94</a>】</p>
<p>4.下方的红色从左到右由黑边红, 左侧的绿色从上到下由黑到绿。红+绿变黄, 所以我们的右上角应该是黄的。</p>
<p>现在我们要把cout的输出流写入文件中。幸好我们有命令行操作符&gt;来定向输出流。在windows操作系统中差不多这样的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build\Release\inOneWeekend.exe &gt; image.ppm</span><br></pre></td></tr></table></figure>

<p>在Mac或者Linux操作系统中, 大概是这个样子的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/inOneWeekend &gt; image.ppm</span><br></pre></td></tr></table></figure>

<p>打开我们输出的文件(我是Mac系统, 我是用ToyViewer打开的, 你可以用你喜欢的任意看图软件来打开。如果你默认的看图软件(比如windows下的图片)不支持ppm格式, 只要Google一下”ppm viewer”装个新的就行。)打开后的结果如下:</p>
<p><img src="https://raytracing.github.io/images/img.first-ppm-image.png"></p>
<p>好耶!这便是图形学中的”hello world”了【吐槽：图形学的hello world不是三角形嘛】。如果你的图像看上去不是这样的, 用文本编辑器打开你的输出文件, 看看里面内容是啥样的。不出意外的话, 正确格式应该是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">P3</span><br><span class="line">200 100</span><br><span class="line">255</span><br><span class="line">0 253 51</span><br><span class="line">1 253 51</span><br><span class="line">2 253 51</span><br><span class="line">3 253 51</span><br><span class="line">5 253 51</span><br><span class="line">6 253 51</span><br><span class="line">7 253 51</span><br><span class="line">8 253 51</span><br></pre></td></tr></table></figure>

<p>如果不是这样的, 你可能当中多了些空行或者类似的什么东西, 因此你的看图软件识别不出来。</p>
<p>如果你想生成别的图像格式来代替基础的PPM, 我强烈安利<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h"><code>stb_image.h</code></a>, 你可以免费在<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h">github</a>上获取。</p>
<h3 id="2-1-加入进度提示"><a href="#2-1-加入进度提示" class="headerlink" title="2.1. 加入进度提示"></a>2.1. 加入进度提示</h3><p>在我们往下走之前, 我们先来加个输出的进度提示。对于查看一次长时间渲染的进度来说, 这不失为一种简便的做法。也可以通过这个进度来判断程序是否卡住或者进入一个死循环。</p>
<p>我们的程序将图片信息写入标准输出流(std::cout), 所以我们不能用这个流输出进度。我们换用错误输出流(std::cerr)来输出进度:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff 带进度条的渲染循环</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">+        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in"><span class="keyword">double</span></span>(i) / image_width;</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="built_in"><span class="keyword">double</span></span>(j) / image_height;</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.2</span>;</span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">            std::cout &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">+std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><a id="vec3"></a></p>
<h2 id="3-vec3向量类"><a href="#3-vec3向量类" class="headerlink" title="3. vec3向量类"></a>3. vec3向量类</h2><p>几乎所有的图形程序都使用类似的类来储存几何向量和颜色。在许多程序中这些向量是四维的(对于位置或者几何向量来说是三维的齐次拓展, 对于颜色来说是RGB加透明通道)。对我们现在这个程序来说, 三维就足够了。我们用一个<code>vec3</code>类来储存所有的颜色, 位置, 方向, 位置偏移, 或者别的什么东西。一些人可能不太喜欢这样做, 因为全都用一个类, 没有限制, 写代码的时候难免会犯二, 比如你把颜色和位置加在一起。他们的想法挺好的, 但是我们想在避免明显错误的同时让代码量尽量的精简。所以这里就先一个类吧。【译注: 之后有添加新的color类】</p>
<p>下面是我的<code>vec3</code>的头文件:</p>
<figure class="highlight c++"><figcaption><span>vec.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vec3</span>() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">            out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * e[<span class="number">0</span>]) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * e[<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * e[<span class="number">2</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用双精度浮点<code>double</code>, 但是有些光线追踪器使用单精度浮点<code>float</code>。这里其实都行, 你喜欢哪个就用那个。头文件的第二部分包括一些向量操作工具函数:</p>
<figure class="highlight c++"><figcaption><span>vec3.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vec3 Utility Functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以使用vec3类将我们的main函数改成这样啦:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff 创建一张颜色渐变的图片</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">+            <span class="function">vec3 <span class="title">color</span><span class="params">(<span class="keyword">double</span>(i)/image_width, <span class="keyword">double</span>(j)/image_height, <span class="number">0.2</span>)</span></span>;</span><br><span class="line">+            color.<span class="built_in">write_color</span>(std::cout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="raycamerabg"></a></p>
<h2 id="4-光线-简单摄像机-以及背景"><a href="#4-光线-简单摄像机-以及背景" class="headerlink" title="4. 光线, 简单摄像机, 以及背景"></a>4. 光线, 简单摄像机, 以及背景</h2><p>所有的光线追踪器都有个一个ray类, 我们假定光线的公式为$\mathbf{p}(t) = \mathbf{a} + t \vec{\mathbf{b}}$。这里的$\mathbf{p}$是三维射线上的一个点。$\mathbf{a}$是射线的原点, $\vec{\mathbf{b}}$是射线的方向。类中的变量$t$是一个实数(代码中为double类型)。$p(t)$接受任意的$t$做为变量, 返回射线上的对应点。如果允许$t$取负值你可以得到整条直线。对于一个正数$t$, 你只能得到原点前部分$\mathbf{a}$, 这常常被称为半条直线, 或者说射线。</p>
<p><img src="https://raytracing.github.io/images/fig.lerp.jpg" alt="Figure 1:Liner interpolation"></p>
<p>我在代码中使用复杂命名, 将函数$p(t)$扩写为<code>ray::at(t)</code>【吐糟: 你之前版本中那个ray::point_at_parameter(t)才叫复杂】</p>
<figure class="highlight c++"><figcaption><span>ray.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">ray</span>(<span class="keyword">const</span> vec3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>    </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">        <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vec3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t*dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>现在我们再拐回来做我们的光线追踪器。光线追踪器的核心是从像素发射射线, 并计算这些射线得到的颜色。这包括如下的步骤: (1)将射线从视点转化为像素坐标 (2)计算光线是否与场景中的物体相交 (3)如果有, 计算交点的颜色。在做光线追踪器的初期, 我会先弄个简单摄像机让代码能跑起来。我也会编写一个简单的<code>color(ray)</code>函数来返回背景颜色值(一个简单的渐变色)。</p>
<p>在使用正方形的图像Debug时我时常会遇到问题, 因为我老是把$x$和$y$弄反。所以我坚持使用200x100这样长宽不等的图像。我会把视点(或者说摄像机, 如果你认为它是个摄像机的话)放在$(0,0,0)$。这里y轴向上, x轴向右, 为了准守使用左手系的规范, 摄像机看向的方向为z轴的负方向。我会把发出射线的原点从图像的左下角开始沿着xy方向做增量直至遍历全图。注意我这里并没有将射线的向量设置为单位向量, 因为我认为这样代码会更加简单快捷。</p>
<p><a target="_blank" rel="noopener" href="https://raytracing.github.io/images/fig.cam-geom.jpg">Figure 2: Camera geometry</a></p>
<p>下面是代码, 射线r现在只是近似的从各个像素的中心射出(现在不必担心精度问题, 因为我们一会儿就会加入抗锯齿):</p>
<figure class="highlight c++"><figcaption><span>main.cc diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line">+    <span class="function">vec3 <span class="title">lower_left_corner</span><span class="params">(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">+    <span class="function">vec3 <span class="title">horizontal</span><span class="params">(<span class="number">4.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">+    <span class="function">vec3 <span class="title">vertical</span><span class="params">(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">+    <span class="function">vec3 <span class="title">origin</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">+            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / image_width;</span><br><span class="line">+            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / image_height;</span><br><span class="line">+            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line">+            vec3 color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            color.<span class="built_in">write_color</span>(std::cout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ray_color(ray)</code>函数根据y值将蓝白做了个线性差值的混合, 我们这里把射线做了个单位化, 以保证y的取值范围$(-1.0&lt;y&lt;1.0)$。因为我们使用y轴做渐变, 所以你可以看到这个蓝白渐变也是竖直的。</p>
<p>我接下来使用了一个标准的小技巧将y的范围从$-1.0 ≤ y ≤ 1.0$映射到了$0 ≤ y ≤ 1.0$。这样$t=1.0$时就是蓝色, 而$t=0.0$时就是白色。在蓝白之间我想要一个混合效果(blend)。现在我们采用的是线性混合(linear blend)或者说线性插值(liner interpolation)。或者简称其为lerp。一个lerp一般来说会是下面的形式:</p>
<p>$$ \text{blendedValue} = (1-t)\cdot\text{startValue} + t\cdot\text{endValue}$$</p>
<p>当$t$从0到1, 我们会渲染出这样的图像:</p>
<p><img src="https://raytracing.github.io/images/img.blue-to-white.png" alt="A blue-to-white gradient depending on ray Y coordinate"></p>
<p><a id="sphere"></a></p>
<h2 id="5-加入球体"><a href="#5-加入球体" class="headerlink" title="5. 加入球体"></a>5. 加入球体</h2><p>让我们为我们的光线追踪器加入一个物体吧!人们通常使用的球体, 因为计算射线是否与球体相交是十分简洁明了的。回想一下我们中学时期学过的球体表面方程, 对于一个半径为$r$的球体来说, 有方程$x^2 + y^2 + z^2 = R^2$, 其中$(x,y,z)$是球面上的点。如果我们想要表示点$(x,y,z)$在球体的内部, 那便有方程$x^2 + y^2 + z^2 &lt; R^2$, 类似的, 如果要表示球体外部的点, 则有$x^2 + y^2 + z^2 &gt; R^2$。</p>
<p>如果球体的球心在$(\mathbf{c}_x, \mathbf{c}_y, \mathbf{c}_z)$, 那么这个式子就会变得丑陋一些:</p>
<p>$$ (x-\mathbf{c}_x)^2 + (y-\mathbf{c}_y)^2 + (z-\mathbf{c}_z)^2 = R^2 $$</p>
<p>在图形学中, 你总希望你方程里面所有东西都是用向量表达的, 这样我们就能用vec3这个类来存储所有的这些xyz相关的东西了。你也许会意识到, 对于到球面上的点$\mathbf{P} = (x,y,z)$到球心$\mathbf{c} = (\mathbf{c}_x,\mathbf{c}_y,\mathbf{c}_z)$的距离可以使用向量表示为$(\mathbf{p} - \mathbf{c})$, 于是就有</p>
<p>$$ (\mathbf{p} - \mathbf{c}) \cdot (\mathbf{p} - \mathbf{c}) = (x-\mathbf{c}_x)^2 + (y-\mathbf{c}_y)^2 + (z-\mathbf{c}_z)^2 $$</p>
<p>于是我们就能得到球面方程的向量形式:</p>
<p>$$ (\mathbf{p} - \mathbf{c}) \cdot (\mathbf{p} - \mathbf{c}) = R^2 $$</p>
<p>我们可以将其解读为”满足方程上述方程的任意一点$\mathbf{p}$一定位于球面上”。我们还要知道射线$p(t) = \mathbf{a} + t\vec{\mathbf{b}}$是否与球体相交。如果说它相交了, 那么肯定有一个$t$使直线上的点$p(t)$满足球面方程。所以我们先来计算满足条件的任意$t$值:</p>
<p>$$ (p(t) - \mathbf{c})\cdot(p(t) - \mathbf{c}) = R^2 $$</p>
<p>或者将$p(t)$展开为射线方程:</p>
<p>$$ (\mathbf{a} + t \vec{\mathbf{b}} - \mathbf{c}) \cdot (\mathbf{a} + t \vec{\mathbf{b}} - \mathbf{c}) = R^2 $$</p>
<p>好啦, 我们需要的代数部分就到这里。现在我们来展开表达式并移项, 得:</p>
<p>$$ t^2 \vec{\mathbf{b}}\cdot\vec{\mathbf{b}} + 2t \vec{\mathbf{b}} \cdot \vec{(\mathbf{a}-\mathbf{c})} + \vec{(\mathbf{a}-\mathbf{c})} \cdot \vec{(\mathbf{a}-\mathbf{c})} - R^2 = 0 $$</p>
<p>方程中的向量和半径$R$都是已知的常量, 唯一的未知数就是$t$, 并且这个等式是关于$t$的一个一元二次方程, 就像你在高中数学课上【？？？】学到的那样。你可以用求根公式来判别交点个数, 为正则2个交点, 为负则1个交点, 为0则没有交点。在图形学中, 代数与几何往往密切相关, 你看图:</p>
<p><img src="https://raytracing.github.io/images/fig.ray-sphere.jpg" alt="Figure 3: Ray-sphere intersection results"></p>
<p>如果我们使用代码来求解, 并使用红色来表示射线击中我们放在(0,0,-1)的小球:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff Rendering a red sphere</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> vec3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">+        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="https://raytracing.github.io/images/img.red-sphere.png" alt="A simple red sphere"></p>
<p>现在我们啥都缺: 例如光照, 反射, 加入更多的物体, 但是我们离成功又近了一步!现在你要注意我们其实求的是直线与球相交的解, $t&lt;0$的那些情况也计算进去了, 而我们只想要直线中一段射线的解。如果你将你的球心设置在$(0,0,1)$你会得到完全相同的结果。这不是一个特性(feature)!【吐槽: 直接说it’s a bug嘛】我们会在接下来的章节修复这个bug。</p>
<p><a id="normalandmultobject"></a></p>
<h2 id="6-面法相与复数物体"><a href="#6-面法相与复数物体" class="headerlink" title="6. 面法相与复数物体"></a>6. 面法相与复数物体</h2><p>为了来给球体着色, 首先我们来定义一下面法相。面法相应该是一种垂直于交点所在平面的三维向量。关于面法相我们存在两个设计抉择。首先是是否将其设计为单位向量, 这样对于着色器来说, 所以我会说”yes!”但是我并没有在代码里这么做, 这部分差异可能会导致一些潜在的bug。所以记住, 这个是个人喜好, 大多数的人喜好使用单位法相。对于球体来说, 朝外的法相是直线与球的交点减去球心:</p>
<p><img src="https://raytracing.github.io/images/fig.sphere-normal.jpg" alt="Figure 4: Sphere surface-normal geometry"></p>
<p>说到底, 其实就是从球心到交点再向外延伸的那个方向。让我们把这部分转变成代码并开始着色。我们暂时还没有光源这样的东西, 所以让我们直接将法相值作为颜色输出吧。对于法相可视化来说, 我们常常将xyz分量的值先映射到0到1的范围(假定$vec{\mathbf{N}}$是一个单位向量, 它的取值范围是-1到1的),再把它赋值给rgb。对于法相来说, 光能判断射线是否与球体相交是不够的, 我们还需求出交点的坐标。在有两个交点的情况下, 我们选取最近的交点smallest(t)。计算与可视化球的法向量的代码如下:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff Rendering surface nornals on a sphere</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> vec3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">+    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+        <span class="built_in"><span class="keyword">return</span></span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">+    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">+    <span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">+    <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">+        vec3 N = <span class="built_in">unit_vector</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">0.5</span>*<span class="built_in">vec3</span>(N.<span class="built_in">x</span>()+<span class="number">1</span>, N.<span class="built_in">y</span>()+<span class="number">1</span>, N.<span class="built_in">z</span>()+<span class="number">1</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">+    t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会得到下面的结果:</p>
<p><img src="https://raytracing.github.io/images/img.normals-sphere.png" alt="A sphere colored according to its normal vectors"></p>
<p>我们再来回顾上面的直线方程:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br></pre></td></tr></table></figure>

<p>首先, 回想一下一个向量与自己的点积就是它的长度的平方(都是$x^2+y^2+z^2$)</p>
<p>其次, 注意其实我们的<code>b</code>有一个系数2, 我们设<code>b=2h</code>, 有:</p>
<p>$$ \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<p>$$ = \frac{-2h \pm \sqrt{(2h)^2 - 4ac}}{2a} $$</p>
<p>$$ = \frac{-2h \pm 2\sqrt{h^2 - ac}}{2a} $$</p>
<p>$$ = \frac{-h \pm \sqrt{h^2 - ac}}{a} $$</p>
<p>所以射线与球体求交的代码其实可以简化成下面这样:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">-<span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">-<span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">-<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius*radius;</span><br><span class="line">-<span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">+<span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">+<span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">+<span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">+<span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">-   <span class="built_in"><span class="keyword">return</span></span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">+   <span class="keyword">return</span> (-half_b - <span class="built_in">sqrt</span>(discriminant) ) / a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好啦, 那么怎么在场景中渲染不止一个球呢? 很直接的我们想到使用一个sphere数组, 这里有个很简洁的好方法: 使用一个抽象类, 任何可能与光线求交的东西实现时都继承这个类, 并且让球以及球列表也都继承这个类。我们该给这个类起个什么样的名字呢? 叫它<code>object</code>好像不错但现在我们使用面向对象编程(oop)。<code>suface</code>是时常被翻牌, 但是如果我们想要体积体(volumes)的话就不太适合了。<code>hittable</code>又过于强调了自己的成员函数<code>hit</code>。所以我哪个都不喜欢, 但是总得给它个名字的嘛, 那我就叫它<code>hittable</code>:</p>
<p><code>hittable</code>类理应有个接受射线为参数的函数, 许多光线追踪器为了便利, 加入了一个区间$t_{min}&lt;t&lt;t_{max}$来判断相交是否有效。对于一开始的光线来说, 这个$t$值总是正的, 但加入这部分对代码实现的一些细节有着不错的帮助。现在有个设计上的问题:我们是否在每次计算求交的时候都要去计算法相?但其实我们只需要计算离射线原点最近的那个交点的法相就行了, 后面的东西会被遮挡。接下来我会给出我的代码, 并将一些计算的结果存在一个结构体里, 来看, 这就是那个抽象类:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    vec3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这是继承自它的<code>sphere</code>球体类:</p>
<figure class="highlight c++"><figcaption><span>sphere.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span>:</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">sphere</span>(vec3 cen, <span class="keyword">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root)/a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            rec.normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            rec.normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>好了, 让我们来谈谈第二个关于面法相设计上的问题吧， 那就是面法相的朝向问题。对于现在来说, 如果光线从球体外部击中球体, 那么法相也是朝外的, 与射线的方向相反(不是数学意义上的严格相反, 只是大致逆着)。如果光线从内部射向球面时, 此时的面法相依然朝外, 与射线方向相同。相对的, 我们也可以总是让法相向量与射线方向相反, 即射线从外部射向球面, 法向量朝外, 射线从内部射向球面, 法向量向着球心。</p>
<p><img src="https://raytracing.github.io/images/fig.normal-possibilities.jpg" alt="Figure 5: Possible directions for sphere surface-normal geometry"></p>
<p>在我们着色前, 我们需要仔细考虑一下采用上面哪种方式, 这对于双面材质来说至关重要。例如一张双面打印的A4纸, 或者玻璃球这样的同时具有内表面和外表面的物体。</p>
<p>如果我们决定让法相永远朝外, 那在我们就得在射入的时候判断是从表面的哪一侧射入的, 我们可以简单的将光线与法相做点乘来判断。如果法相与光线方向相同, 那就是从内部击中内表面, 如果相反则是从外部击中外表面。【译注: $dot(a,b) = cos\theta|a||b|$】</p>
<figure class="highlight c++"><figcaption><span>sphere.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">dot</span>(ray_direction, outward_normal) &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// ray is inside the sphere</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ray is outside the sphere</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们永远让法相与入射方向相反, 我们就不用去用点乘来判断射入面是内侧还是外侧了, 但相对的, 我们需要用一个变量储存摄入面的信息:</p>
<figure class="highlight c++"><figcaption><span>sphere.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> front_face;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dot</span>(ray_direction, outward_normal) &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// ray is inside the sphere</span></span><br><span class="line">    normal = -outward_normal;</span><br><span class="line">    front_face = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ray is outside the sphere</span></span><br><span class="line">    normal = outward_normal;</span><br><span class="line">    front_face = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实采取哪种策略, 关键在于你想把这部分放在着色阶段还是几何求交的阶段。【译注:反正都要算的, v2.0的时候是在着色阶段判别的, v3.0把它放在了求交阶段】。在本书中我们我们的材质类型会比我们的几何图元类型多, 所以为了有更少的代码量, 我们会在几何部分先判别射入面是内侧还是外侧。这当然也是一种个人喜好。</p>
<p>我们在结构体<code>hit_record</code>中加入<code>front_face</code>变量, 我们接下来还会弄一些动态模糊相关的事情(Book2 chapter1),所以我还会加入一个时间变量:</p>
<figure class="highlight c++"><figcaption><span>hittable.h diff The hittable class with time and side</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ifndef HITTABLE_H</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    vec3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">+    <span class="keyword">double</span> t;</span><br><span class="line">+    <span class="keyword">bool</span> front_face;</span><br><span class="line"></span><br><span class="line">+    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来我们在求交时加入射入面的判别:</p>
<figure class="highlight c++"><figcaption><span>sphere.h diff The sphere class with normal determination</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root)/a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">+            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">+            rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">+            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">+            rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们加入存放物体的列表</p>
<figure class="highlight c++"><figcaption><span>hittable_list.h  The hittable_list classs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span>:</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-1-一些C-的新特性"><a href="#6-1-一些C-的新特性" class="headerlink" title="6.1. 一些C++的新特性"></a>6.1. 一些C++的新特性</h3><p><code>hittable_list</code>类使用了两种C++的特性:<code>vector</code>和<code>shared_ptr</code>, 如果你并不熟悉C++, 你可能会感到有些困惑。</p>
<p><code>shared_ptr&lt;type&gt;</code>是指向一些已分配内存的类型的指针。每当你将它的值赋值给另一个智能指针时, 物体的引用计数器就会+1。当智能指针离开它所在的生存范围(例如代码块或者函数外), 物体的引用计数器就会-1。一旦引用计数器为0, 即没有任何智能指针指向该物体时, 该物体就会被销毁</p>
<p>一般来说, 智能指针首先由一个刚刚新分配好内存的物体来初始化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">double</span>&gt; double_ptr = make_shared&lt;<span class="keyword">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line">shared_ptr&lt;vec3&gt;   vec3_ptr   = make_shared&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line">shared_ptr&lt;sphere&gt; sphere_ptr = make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p><code>make_shared&lt;thing&gt;(thing_constructor_params ...)</code>为指定的类型分配一段内存, 使用你指定的构造函数与参数来创建这个类, 并返回一个智能指针<code>shared_ptr&lt;thing&gt;</code></p>
<p>使用C++的<code>auto</code>类型关键字, 可以自动推断<code>make_shared&lt;type&gt;</code>返回的智能指针类型, 于是我们可以把上面的代码简化为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> double_ptr = make_shared&lt;<span class="keyword">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line"><span class="keyword">auto</span> vec3_ptr   = make_shared&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line"><span class="keyword">auto</span> sphere_ptr = make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>我们在代码中使用智能指针的目的是为了能让多个几何图元共享一个实例(举个栗子, 一堆不同球体使用同一个纹理材质), 并且这样内存管理比起普通的指针更加的简单方便。</p>
<p><code>std::shared_ptr</code>在头文件<code>&lt;memory&gt;</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>第二个你可能不太熟悉的C++特性是<code>std::vector</code>。这是一个类似数组的结构类型, 可以存储任意指定的类型。在上面的代码中, 我们将hittable类型的智能指针存入<code>vector</code>中, 随着<code>objects.push_back(object)</code>的调用, <code>object</code>被存入<code>vector</code>的末尾, 同时<code>vector</code>的储存空间会自动增加。</p>
<p><code>std::vector</code>在头文件<code>&lt;vector&gt;</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>最后, 位于<code>hittable_list.h</code>文件开头部分的<code>using</code>语句告诉编译器, <code>shared_ptr</code>与<code>make_shared</code>是来自<code>std</code>库的。这样我们在使用它们之前就不用每次都加上前缀<code>std::</code>。</p>
<h3 id="6-2-常用的常数与工具函数"><a href="#6-2-常用的常数与工具函数" class="headerlink" title="6.2. 常用的常数与工具函数"></a>6.2. 常用的常数与工具函数</h3><p>我们需要在头文件中定义一些常用的常数。目前为止我们只需要定义无穷。但是我们先把pi在这里定义好, 之后要用的。对于pi来说并没有什么跨平台的标准定义【译注: 这就是为什么不使用之前版本中M_PI宏定义的原因】, 所以我们自己来定义一下。我们在<code>rtweekend.h</code>中给出了一些未来常用的常数和函数:</p>
<figure class="highlight c++"><figcaption><span>rtweekend.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTWEEKEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTWEEKEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Usings</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> infinity = std::numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility Functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="keyword">double</span> degrees)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * pi / <span class="number">180</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">ffmin</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt;= b ? a : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">ffmax</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt;= b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Common Headers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>以及这是更新后的main函数:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">+    hit_record rec;</span><br><span class="line">+    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">+    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">+    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">lower_left_corner</span><span class="params">(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">horizontal</span><span class="params">(<span class="number">4.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vertical</span><span class="params">(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">origin</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">+    hittable_list world;</span><br><span class="line">+    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">+    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in"><span class="keyword">double</span></span>(i) / image_width;</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in"><span class="keyword">double</span></span>(j) / image_height;</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line"></span><br><span class="line">+            vec3 color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line"></span><br><span class="line">            color.<span class="built_in">write_color</span>(std::cout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就会得到一张使用法向作为球体颜色值的图片。当你想查看模型的特征细节与瑕疵时, 输出面法向作为颜色值不失为一种很好的方法。</p>
<p><img src="https://raytracing.github.io/images/img.normals-sphere-ground.png" alt="Resulting render of normals-colored sphere with ground"></p>
<h2 id="7-反走样-抗锯齿"><a href="#7-反走样-抗锯齿" class="headerlink" title="7. 反走样(抗锯齿)"></a>7. 反走样(抗锯齿)</h2><p>真实世界中的摄像机拍摄出来的照片是没有像素状的锯齿的。因为边缘像素是由背景和前景混合而成的。我们也可以在程序中简单的对每个边缘像素多次采样取平均达到类似的效果。我们这里不会使用分层采样。尽管我自己常常在我的程序里使用这种有争议的方法。对某些光线追踪器来说分层采样是很关键的部分, 但是对于我们写的这个小光线追踪器并不会有什么很大的提升, 只会让代码更加丑陋。我们会在这里将摄像机类抽象一下, 以便于后续能有一个更酷的摄像机。</p>
<p>我们还需要一个能够返回真随机数的一个随机数生成器。默认来说这个函数应该返回$0≤r&lt;1$的随机数。注意这个范围取不到1是很重要的。有时候我们能从这个特性中获得好处。</p>
<p>一个简单的实现方法是, 使用<code>&lt;cstdlib&gt;</code>中的<code>rand()</code>函数。这个函数会返回0到RAND_MAX中的一个任意整数。我们将下面的一小段代码加到<code>rtweekend.h</code>中, 就能得到我们想要的随机函数了:</p>
<figure class="highlight c++"><figcaption><span>rtweekend.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a random real in [0,1).</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a random real in [min,max).</span></span><br><span class="line">    <span class="keyword">return</span> min + (max-min)*<span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传统C++并没有随机数生成器, 但是新版C++中的<random>头实现了这个功能(某些专家觉得这种方法不太完美)。如果你想使用这种方法, 你可以参照下面的代码:</p>
<figure class="highlight c++"><figcaption><span>rtweekend.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> std::mt19937 generator;</span><br><span class="line">    <span class="keyword">static</span> std::function&lt;<span class="built_in"><span class="keyword">double</span></span>()&gt; rand_generator =</span><br><span class="line">        std::<span class="built_in">bind</span>(distribution, generator);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand_generator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于给定的像素, 我们发射多条射线进行多次采样。然后我们对颜色结果求一个平均值:</p>
<p><img src="https://raytracing.github.io/images/fig.pixel-samples.jpg" alt="Figure 6: Pixel samples"></p>
<p>综上, 我们对我们的简单的轴对齐摄像机类进行了一次封装:</p>
<figure class="highlight c++"><figcaption><span>camera.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>() &#123;</span><br><span class="line">            lower_left_corner = <span class="built_in">vec3</span>(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">            horizontal = <span class="built_in">vec3</span>(<span class="number">4.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            origin = <span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 origin;</span><br><span class="line">        vec3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了对多重采样的颜色值进行计算, 我们升级了<code>vec3::write_color()</code>函数。我们不会在每次发出射线采样时都计算一个0-1之间的颜色值, 而是一次性把所有的颜色都加在一起, 然后最后只需要简单的一除(除以采样点个数)。另外, 我们给头文件<code>rtweekend.h</code>加入了一个新函数<code>clamp(x,min,max)</code>, 用来将<code>x</code>限制在[min,max]区间之中:</p>
<figure class="highlight c++"><figcaption><span>rtweekend.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">clamp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>vec.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Divide the color total by the number of samples.</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    <span class="keyword">auto</span> r = scale * e[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> g = scale * e[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> b = scale * e[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数也发生了变化:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line">    camera cam;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">vec3 <span class="title">color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / image_width;</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / image_height;</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            color.<span class="built_in">write_color</span>(std::cout, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>停, 放大放大再放大, 看啊, 每一个像素都是背景和前景的混合:</p>
<p><img src="https://raytracing.github.io/images/img.antialias.png" alt="Close-up of antialiased pixels"></p>
<h2 id="8-漫反射材质"><a href="#8-漫反射材质" class="headerlink" title="8. 漫反射材质"></a>8. 漫反射材质</h2><p>既然我们已经有了物体的类和多重采样, 我们不妨再加入一些逼真的材质吧。我们先从漫反射材质开始。设计上的问题又来了:我们是把材质和物体设计成两个类, 这样就可以将材质赋值给物体类的成员变量, 还是说让它们紧密结合,这对于使用几何信息来生成纹理的程序来说是很便利的 。我们会采取将其分开的做法————实际上大多数的渲染器都是这样做的————但是记得注意的确是有两种设计方法的。 </p>
<p>漫反射材质不仅仅接受其周围环境的光线, 还会在散射时使光线变成自己本身的颜色。光线射入漫反射材质后, 其反射方向是随机的。所以如果我们为下面这两个漫发射的球射入三条光线, 光线都会有不同的反射角度:</p>
<p><img src="https://raytracing.github.io/images/fig.light-bounce.jpg" alt="Light ray bounces"></p>
<p>并且大部分的光线都会被吸收, 而不是被反射。表面越暗, 吸收就越有可能发生。我们使用任意的算法生成随机的反射方向, 就能让其看上去像一个粗糙不平的漫反射材质。这里我们采用最简单的算法就能得到一个理想的漫反射表面(其实是懒得写lambertian所以用了一个数学上近似的方法)。</p>
<p>(读者Vassillen Chizhov 提供了这个方法, 虽然并不是很精确。我们会在章节最后提准确的lambertian表达式, 而且其并不会很复杂)</p>
<p>好, 现在有两个单位球相切于点$p$, 这两个球体的球心为$(p+\vec{N})$和$(p-\vec{N})$, $\vec{N}$是球体表面的法向量。球心为$(p-\vec{N})$的那个球在表面的内部, 球心为$(p+\vec{N})$的球在表面的外部。选择和光线原点位于表面同一侧的那个单位球, 并从球中随机选取一点$s$, 向量$(s-p)$就是我们要求的反射光线的方向:</p>
<p><img src="https://raytracing.github.io/images/fig.rand-vector.jpg" alt="Figure 8:Generating a random diffuse bounce ray"></p>
<p>我们需要一个算法来生成球体内的随机点。我们会采用最简单的做法:否定法(rejection method)。首先, 在一个xyz取值范围为-1到+1的单位立方体中选取一个随机点, 如果这个点在球外就重新生成直到该点在球内:</p>
<figure class="highlight c++"><figcaption><span>vec3.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max), <span class="built_in">random_double</span>(min,max));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>vec.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = vec3::<span class="built_in">random</span>(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用我们新的生成随机随机反射方向的函数来更新一下我们的<code>ray_color()</code>函数:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        vec3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有个潜在的问题: 注意<code>ray_color</code>函数是一个递归函数。那么递归终止的条件是什么呢?当它没有击中任何东西。但是, 在某些条件下, 达到这个终止条件的时间会非常长, 长到足够爆了函数栈【译注:想象一下一条光线在一个镜子材质的密封的盒子(并不吸收光线)中反复折射, 永无尽头】。为了避免这种情况的发生, 我们使用一个变量<code>depth</code>限制递归层数。当递归层数达到限制值时我们终止递归, 返回黑色:【译注: 可以试试返回纯红(1,0,0), 然后渲染一下, 大致看一下是哪里在不停的发生散射】</p>
<figure class="highlight c++"><figcaption><span>main.cc diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">+    hit_record rec;</span><br><span class="line"></span><br><span class="line">+    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">+    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">+        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">+    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">+        vec3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">+    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">vec3 <span class="title">color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / image_width;</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / image_height;</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">+               color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            color.<span class="built_in">write_color</span>(std::cout, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="https://raytracing.github.io/images/img.first-diffuse.jpg" alt="第一次渲染出漫反射材质的球体"></p>
<p>注意球下面是有影子的。这个图片非常的暗, 但是我们的球在散射的时候只吸收了一半的能量。如果你看不见这个阴影, 别担心, 我们现在来修复一下。现实世界中的这个球明显是应该更加亮一些的。这是因为所有的看图软件都默认图像已经经过了伽马校正(gamma corrected)。即在图片存入字节之前, 颜色值发生了一次转化。这么做有许多好处, 但这并不是我们这里所讨论的重点。我们使用”gamma 2”空间, 就意味着最终的颜色值要加上指数$1/gamma$, 在我们的例子里就是 ½, 即开平方根:</p>
<figure class="highlight c++"><figcaption><span>vec.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(std::ostream &amp;out, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Divide the color total by the number of samples and gamma-correct</span></span><br><span class="line">    <span class="comment">// for a gamma value of 2.0.</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="built_in">sqrt</span>(scale * e[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">auto</span> g = <span class="built_in">sqrt</span>(scale * e[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">sqrt</span>(scale * e[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了, 现在看上去更灰了, 如我们所愿:</p>
<p><img src="https://raytracing.github.io/images/img.gamma-correct.jpg" alt="伽马校正后的漫反射球体"></p>
<p>这里还有个不太重要的潜在bug。有些物体反射的光线会在$t=0$时再次击中自己。然而由于精度问题, 这个值可能是$t=-0.000001$或者是$t=0.0000000001$或者任意接近0的浮点数。所以我们要忽略掉0附近的一部分范围, 防止物体发出的光线再次与自己相交。【译注: 小心自相交问题】</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br></pre></td></tr></table></figure>

<p>这样我们就能避免阴影痤疮(shadow ance)的产生。是滴, 这种现象的确是叫这个名字。</p>
<p>拒绝法生成的点是单位球体积内的的随机点, 这样生成的向量大概率上会和法线方向相近, 并且极小概率会沿着入射方向反射回去。这个分布律的表达式有一个$\cos^3 (\phi)$的系数, 其中 $\phi$ 是反射光线距离法向量的夹角。这样当光线从一个离表面很小的角度射入时, 也会散射到一片很大的区域, 对最终颜色值的影响也会更低。</p>
<p>然而, 事实上的lambertian的分布律并不是这样的, 它的系数是$\cos (\phi)$。真正的lambertian散射后的光线距离法相比较近的概率会更高, 但是分布律会更加均衡。这是因为我们选取的是单位球面上的点。我们可以通过在单位球内选取一个随机点, 然后将其单位化来获得该点。【译注: 然而下面的代码却用了极坐标的形式】</p>
<figure class="highlight c++"><figcaption><span>vec3.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">2</span>*pi);</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="built_in">sqrt</span>(<span class="number">1</span> - z*z);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(r*<span class="built_in">cos</span>(a), r*<span class="built_in">sin</span>(a), z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raytracing.github.io/images/fig.rand-unitvector.png" alt="Figure 9: Generating a random unit vector"></p>
<p>我们使用新函数<code>random_unit_vector()</code>替换现存的<code>random_unit_sphere()</code>:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        vec3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到这样的图片, 和之前很相像:</p>
<p><img src="https://raytracing.github.io/images/img.correct-lambertian.png" alt="Correct rendering of Lambertian spheres"></p>
<p>我们的场景太简单, 区分这两种方法是比较难的。但你应该能够注意到视觉上的一些差异:</p>
<p>1.阴影部分少了<br>2.大球和小球都变亮了</p>
<p>这些变化都是由散射光线的单位规整化引起的, 现在更少的光线会朝着发现方向散射。对于漫发射的物体来说, 他们会变得更亮。因为更多光线朝着摄像机反射。对于阴影部分来说, 更少的光线朝上反射, 所以小球下方的大球区域会变得更加明亮。</p>
<p>这本书很长一段时间都采用的是先前的版本, 直到后来有一天大家发现它其实只是理想lambertian漫发射的近似, 其并不正确。这个错误在本书中留存了那么长时间, 主要是因为:</p>
<p>1.概率分布的数学证明算错了<br>2.视觉上来说, 并不能直接看出$\cos (\phi)$的概率分配是我们所需要的</p>
<p>因为大家日常生活中的物体都是发生了完美的漫反射, 所以我们很难养成对光照下物体是如何表现的视觉直觉。</p>
<p>为了便于大家理解, 简单来说两种方法都选取了一个随机方向的向量, 不过一种是从单位球体内取的, 其长度是随机的, 另一种是从单位球面上取的, 长度固定为单位向量长度。为什么要采取单位球面并不是能很直观的一眼看出。</p>
<p>另一种具有启发性的方法是, 直接从入射点开始选取一个随机的方向, 然后再判断是否在法向量所在的那个半球。在使用lambertian漫发射模型前, 早期的光线追踪论文中大部分使用的都是这个方法:</p>
<figure class="highlight c++"><figcaption><span>vec3.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="keyword">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>) <span class="comment">// In the same hemisphere as the normal</span></span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将我们的新函数套入<code>ray_color()</code>函数:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        vec3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(<span class="built_in">ray</span>(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到如下的图片:</p>
<p><img src="https://raytracing.github.io/images/img.rand-hemispherical.png" alt="使用半球面向量渲染漫反射球体"></p>
<p>我们的场景会随着本书的深入会变得越来越复杂。这里鼓励大家在之后都试一下这几种不同的漫反射渲染法。大多数场景都会有许多的漫反射材质。你可以从中培养出你对这几种方法的敏感程度。</p>
<p><a id="metal"></a></p>
<h2 id="9-金属材质"><a href="#9-金属材质" class="headerlink" title="9. 金属材质"></a>9. 金属材质</h2><p>如果我们想让不同的物体能拥有不同的材质, 我们又面临着一个设计上的抉择。我们可以设计一个宇宙无敌大材质, 这个材质里面有数不胜数的参数和材质类型可供选择。这样其实也不错, 但我们还可以设计并封装一个抽象的材质类。我反正喜欢后面一种, 对于我们的程序来说, 一个材质类应该封装两个功能进去:</p>
<p>1.生成散射后的光线(或者说它吸收了入射光线)<br>2.如果发生散射, 决定光线会变暗多少(attenuate)</p>
<p>下面来看一下这个抽象类:</p>
<figure class="highlight c++"><figcaption><span>material.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">material</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在函数中使用hit_record作为传入参数, 就可以不用传入一大堆变量了。当然如果你想传一堆变量进去的话也行。这也是个人喜好。当然物体和材质还要能够联系在一起。在C++中你只要告诉编译器, 我们在<code>hit_record</code>里面存了个材质的指针。</p>
<figure class="highlight c++"><figcaption><span>hittable.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">material</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    vec3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">bool</span> front_face;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>光线会如何与表面交互是由具体的材质所决定的。<code>hit_record</code>在设计上就是为了把一堆要传的参数给打包在了一起。当光线射入一个表面(比如一个球体), <code>hit_record</code>中的材质指针会被球体的材质指针所赋值, 而球体的材质指针是在<code>main()</code>函数中构造时传入的。当<code>color()</code>函数获取到<code>hit_record</code>时, 他可以找到这个材质的指针, 然后由材质的函数来决定光线是否发生散射, 怎么散射。</p>
<p>所以我们必须在球体的构造函数和变量区域中加入材质指针, 以便之后传给<code>hit_record</code>。见下面高亮的代码行:</p>
<figure class="highlight c++"><figcaption><span>sphere.h diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span>:</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">+        <span class="built_in">sphere</span>(vec3 cen, <span class="keyword">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">+            : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">+        shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root)/a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;                </span><br><span class="line">            rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">+            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我们之前写过的Lambertian(漫反射)材质来说, 这里有两种理解方法, 要么是光线永远发生散射, 每次散射衰减至R, 要么是光线并不衰减, 转而物体吸收(1-R)的光线。你也可以当成是这两种的结合。于是我们可以写出Lambertian的材质类:</p>
<figure class="highlight c++"><figcaption><span>material.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">lambertian</span>(<span class="keyword">const</span> vec3&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            vec3 scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意我们也可以让光线根据一定的概率$p$发生散射【译注: 若判断没有散射, 光线直接消失】, 并使光线的衰减率(代码中的attenuation)为$albedo/p$。随你的喜好来。</p>
<p>对于光滑的金属材质来说, 光线是不会像漫反射那样随机散射的, 而是产生反射。关键是:对于一个金属状的镜子, 光线具体是怎么反射的呢?向量数学是我们的好朋友:</p>
<p><img src="https://raytracing.github.io/images/fig.ray-reflect.jpg" alt="光线发生反射"></p>
<p>反射方向的向量如图所示为$\vec{V}+2\vec{B}$, 其中我们规定向量$\vec{N}$是单位向量, 但$\vec{V}$不一定是。向量B的长度应为$\vec{V}\cdot\vec{N}$, 因为向量$\vec{V}$与向量$\vec{N}$的方向相反, 这里我们需要再加上一个负号, 于是有:</p>
<figure class="highlight c++"><figcaption><span>vec3.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">reflect</span><span class="params">(<span class="keyword">const</span> vec3&amp; v, <span class="keyword">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v - <span class="number">2</span>*<span class="built_in">dot</span>(v,n)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>金属材质使用上面的公式来计算反射方向:</p>
<figure class="highlight c++"><figcaption><span>material.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">metal</span>(<span class="keyword">const</span> vec3&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还需要修改一下color函数:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">+        ray scattered;</span><br><span class="line">+        vec3 attenuation;</span><br><span class="line">+        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">+            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world, depth<span class="number">-1</span>);</span><br><span class="line">+        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = <span class="built_in">unit_vector</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们给场景加入一些金属球:</p>
<figure class="highlight c++"><figcaption><span>main.cc diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">+    hittable_list world;</span><br><span class="line"></span><br><span class="line">+    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(</span><br><span class="line">+        <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>))));</span><br><span class="line">+</span><br><span class="line">+    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(</span><br><span class="line">+        <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>))));</span><br><span class="line"></span><br><span class="line">+    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>))));</span><br><span class="line">+    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>))));</span><br><span class="line"></span><br><span class="line">    camera cam;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">vec3 <span class="title">color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / image_width;</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / image_height;</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            color.<span class="built_in">write_color</span>(std::cout, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就能得到这样的图片:</p>
<p><img src="https://raytracing.github.io/images/img.metal-shiny.png" alt="闪耀的金属球"></p>
<p>我们还可以给反射方向加入一点点随机性, 只要在算出反射向量后, 在其终点为球心的球内随机选取一个点作为最终的终点:</p>
<p>当然这个球越大, 金属看上去就更加模糊(fuzzy, 或者说粗糙)。所以我们这里引入一个变量来表示模糊的程度(fuzziness)(所以当fuzz=0时不会产生模糊)。如果fuzz, 也就是随机球的半径很大, 光线可能会散射到物体内部去。这时候我们可以认为物体吸收了光线。</p>
<figure class="highlight c++"><figcaption><span>material.h diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">+        <span class="built_in">metal</span>(<span class="keyword">const</span> vec3&amp; a, <span class="keyword">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">+            scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz*<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);<span class="comment">//dot&lt;0我们认为吸收</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 albedo;</span><br><span class="line">+        <span class="keyword">double</span> fuzz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以将模糊值设置为0.3和1.0, 图片会变成这样:</p>
<p><img src="https://raytracing.github.io/images/img.metal-fuzz.png" alt="模糊的金属"></p>
<p><a id="dielectrics"></a></p>
<h2 id="10-绝缘体材质"><a href="#10-绝缘体材质" class="headerlink" title="10. 绝缘体材质"></a>10. 绝缘体材质</h2><p>透明的材料, 例如水, 玻璃, 和钻石都是绝缘体。当光线击中这类材料时, 一条光线会分成两条, 一条发生反射, 一条发生折射。我们会采取这样的策略: 每次光线与物体相交时, 要么反射要么折射, 一次只发生一种情况,随机选取。反正最后采样次数多, 会给这些结果取个平均值。</p>
<p>折射部分是最难去debug的部分。我常常一开始让所有的光线只发生折射来调试。在这个项目中, 我加入了两个这样的玻璃球, 并且得到下图(我还没教你怎么弄出这样的玻璃球, 你先往下读, 一会儿你就知道了):</p>
<p><img src="https://raytracing.github.io/images/img.glass-first.png" alt="图10-1"></p>
<p>这图看上去是对的么? 玻璃球在现实世界中看上去和这差不多。但是, 其实这图不对。玻璃球应该会翻转上下, 也不会有这种奇怪的黑圈。我输出了图片中心的一条光线来debug, 发现它完全错了, 你调试的时候也可以这样来。</p>
<p>折射法则是由Snell法则定义的:</p>
<p>$$ \eta \cdot \sin\theta = \eta’ \cdot \sin\theta’ $$</p>
<p>$\theta$与$\theta’$是入射光线与折射光线距离法相的夹角,$\eta$与$\eta’$(读作eta和eta prime)是介质的折射率(规定空气为1.0, 玻璃为1.3-1.7,钻石为2.4), 如图:</p>
<p><img src="https://raytracing.github.io/images/fig.ray-refract.jpg" alt="折射光线示意图"></p>
<p>为了解出折射光线的方向, 我们需要解出$\sin\theta$:</p>
<p>$$ \sin\theta’ = \frac{\eta}{\eta’} \cdot \sin\theta $$</p>
<p>在折射介质部分有射线光线$\mathbf{R’}$与法向量$\mathbf{N’}$, 它们的夹角为$\theta’$。我们可以把光线$\mathbf{R’}$分解成垂直和水平与法向量$\mathbf{N’}$的两个向量:</p>
<p>$$ \mathbf{R’} = \mathbf{R’}<em>{\parallel} + \mathbf{R’}</em>{\bot} $$</p>
<p>如果要解出这两个向量, 有:</p>
<p>$$ \mathbf{R’}_{\parallel} = \frac{\eta}{\eta’} (\mathbf{R} + \cos\theta \mathbf{N}) $$</p>
<p>$$ \mathbf{R’}<em>{\bot} = -\sqrt{1 - |\mathbf{R’}</em>{\parallel}|^2} \mathbf{N} $$</p>
<p>你可以自己推导,证明。我们这里先直接拿来当结论用了。这本书有些别的地方也是, 并不需要你完全会证明。【译注: 自己推推也没坏处】</p>
<p>然后我们来解$\cos\theta$, 下面是著名的点乘的公式定义:</p>
<p>$$ \mathbf{A} \cdot \mathbf{B} = |\mathbf{A}| |\mathbf{B}| \cos\theta $$</p>
<p>如果我们将$\mathbf{A}$与$\mathbf{B}$归一化为单位向量:</p>
<p>$$ \mathbf{A} \cdot \mathbf{B} = \cos\theta $$</p>
<p>于是我们可以这样表达垂直的那个向量:</p>
<p>$$ \mathbf{R’}_{\parallel} = \frac{\eta}{\eta’} (\mathbf{R} + (\mathbf{-R} \cdot \mathbf{N}) \mathbf{N}) $$</p>
<p>根据上述公式, 我们就能写出计算折射光线$\mathbf{R’}$的函数:</p>
<figure class="highlight c++"><figcaption><span>vec3.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">refract</span><span class="params">(<span class="keyword">const</span> vec3&amp; uv, <span class="keyword">const</span> vec3&amp; n, <span class="keyword">double</span> etai_over_etat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = <span class="built_in">dot</span>(-uv, n);</span><br><span class="line">    vec3 r_out_parallel =  etai_over_etat * (uv + cos_theta*n);</span><br><span class="line">    vec3 r_out_perp = -<span class="built_in">sqrt</span>(<span class="number">1.0</span> - r_out_parallel.<span class="built_in">length_squared</span>()) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_parallel + r_out_perp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个只会发生折射的绝缘体材质为:</p>
<figure class="highlight c++"><figcaption><span>material.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">dielectric</span>(<span class="keyword">double</span> ri) : <span class="built_in">ref_idx</span>(ri) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            attenuation = <span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> etai_over_etat;</span><br><span class="line">            <span class="keyword">if</span> (rec.front_face) &#123;</span><br><span class="line">                etai_over_etat = <span class="number">1.0</span> / ref_idx;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                etai_over_etat = ref_idx;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">            vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, etai_over_etat);</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ref_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://raytracing.github.io/images/img.glass-always-refract.png" alt="只发生折射的玻璃材质"></p>
<p>现在看上去图好像不太对, 这是因为当光线从高折射律介质射入低折射率介质时, 对于上述的Snell方程可能没有实解【$\sin\theta&gt;1$】。这时候就不会发生折射, 所以就会出现许多小黑点。我们回头看一下snell法则的式子:</p>
<p>$$ \sin\theta’ = \frac{\eta}{\eta’} \cdot \sin\theta $$</p>
<p>如果光线从玻璃($\eta = 1.5$)射入空气($\eta = 1.0$)</p>
<p>$$ \sin\theta’ = \frac{1.5}{1.0} \cdot \sin\theta $$</p>
<p>又因为$\sin\theta’$是不可能比1大的,所以一旦这种情况发生了:</p>
<p>$$ \frac{1.5}{1.0} \cdot \sin\theta &gt; 1.0 $$</p>
<p>那就完蛋了, 方程无解了。所以我们认为光线无法发生折射的时候, 他发生了反射:</p>
<figure class="highlight c++"><figcaption><span>material.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(etai_over_etat * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// Must Reflect</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Can Refract</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所有的光线都不发生折射, 转而发生了反射。因为这种情况常常在实心物体的内部发生, 所以我们称这种情况被称为”全内反射”。这也当你浸入水中时, 你发现水与空气的交界处看上去像一面镜子的原因。</p>
<p>我们可以用三角函数解出sin_theta</p>
<p>$$ \sin\theta = \sqrt{1 - \cos^2\theta} $$</p>
<p>其中的cos_theta为</p>
<p>$$ \cos\theta = \mathbf{R} \cdot \mathbf{N} $$</p>
<figure class="highlight c++"><figcaption><span>material.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> cos_theta = <span class="built_in">ffmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line"><span class="keyword">if</span>(etai_over_etat * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// Must Reflect</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Can Refract</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个在可以偏折的情况下总是偏折, 其余情况发生反射的绝缘体材质为:</p>
<figure class="highlight c++"><figcaption><span>material.h diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">dielectric</span>(<span class="keyword">double</span> ri) : <span class="built_in">ref_idx</span>(ri) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            attenuation = <span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> etai_over_etat = (rec.front_face) ? (<span class="number">1.0</span> / ref_idx) : (ref_idx);</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">+            <span class="keyword">double</span> cos_theta = <span class="built_in">ffmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">+            <span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line">+            <span class="keyword">if</span> (etai_over_etat * sin_theta &gt; <span class="number">1.0</span> ) &#123;</span><br><span class="line">+                vec3 reflected = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">+                scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">+                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">+            &#125;</span><br><span class="line"></span><br><span class="line">+            vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, etai_over_etat);</span><br><span class="line">+            scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">+            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ref_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的光线衰减率为1——就是不衰减, 玻璃表面不吸收光的能量。如果我们使用下面的参数:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>))));</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>))));</span><br><span class="line"></span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>)));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="https://raytracing.github.io/images/img.glass-sometimes-refract.png" alt="既发生折射又发生反射的材质"></p>
<p>现实世界中的玻璃, 发生折射的概率会随着入射角而改变——从一个很狭窄的角度去看玻璃窗, 它会变成一面镜子。这个式子又丑又长, 好在我们有个数学上近似的等式, 它是由Christophe Schlick提出的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">schlick</span><span class="params">(<span class="keyword">double</span> cosine, <span class="keyword">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r0 = (<span class="number">1</span>-ref_idx) / (<span class="number">1</span>+ref_idx);</span><br><span class="line">    r0 = r0*r0;</span><br><span class="line">    <span class="keyword">return</span> r0 + (<span class="number">1</span>-r0)*<span class="built_in">pow</span>((<span class="number">1</span> - cosine),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是我们完整版的玻璃材质:</p>
<figure class="highlight c++"><figcaption><span>material.h diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">dielectric</span>(<span class="keyword">double</span> ri) : <span class="built_in">ref_idx</span>(ri) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            attenuation = <span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> etai_over_etat = (rec.front_face) ? (<span class="number">1.0</span> / ref_idx) : (ref_idx);</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">            <span class="keyword">double</span> cos_theta = <span class="built_in">ffmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line">            <span class="keyword">if</span> (etai_over_etat * sin_theta &gt; <span class="number">1.0</span> ) &#123;</span><br><span class="line">                vec3 reflected = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">                scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">+            <span class="keyword">double</span> reflect_prob = <span class="built_in">schlick</span>(cos_theta, etai_over_etat);</span><br><span class="line">+            <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; reflect_prob)</span><br><span class="line">+            &#123;</span><br><span class="line">+                vec3 reflected = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">+                scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">+                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">+            &#125;</span><br><span class="line">            vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, etai_over_etat);</span><br><span class="line">            scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ref_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里有个简单又好用的trick, 如果你将球的半径设为负值, 形状看上去并没什么变化, 但是法相全都翻转到内部去了。所以就可以用这个特性来做出一个通透的玻璃球:【把一个小球套在大球里, 光线发生两次折射, 于是负负得正, 上下不会颠倒】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>))));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>))));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>)));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, make_shared&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">-0.45</span>, make_shared&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br></pre></td></tr></table></figure>

<p>就有:</p>
<p><img src="https://raytracing.github.io/images/img.glass-hollow.png" alt="一个通透的玻璃球"></p>
<p><a id="positionablecamera"></a></p>
<h2 id="11-可自定义位置的摄像机"><a href="#11-可自定义位置的摄像机" class="headerlink" title="11. 可自定义位置的摄像机"></a>11. 可自定义位置的摄像机</h2><p>摄像机总是和绝缘体一样难以debug。所以我总是一步步搭建我的摄像机类。首先, 我们使摄像机能调整其视野范围(field of view, fov)。fov是你的视角。因为我们的图片不是方的, 所以垂直和水平的fov值是不同的。我总是使用垂直方向的fov。并且我总是使用角度制来传参, 在构造函数中再将其转化为弧度——这也是我的个人喜好。</p>
<p>首先我让射线从原点射向$z=-1$平面。我们当然也可以让其射向$z=-2$的平面,或者其他的什么值都行, 反正$h$和这个距离$d$是成比例的。</p>
<p><img src="https://raytracing.github.io/images/fig.cam-view-geom.jpg" alt="摄像机示意图"></p>
<p>显然, $h = \tan(\frac{\theta}{2})$。我们的摄像机类现在变成:</p>
<figure class="highlight c++"><figcaption><span>camera.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">+        <span class="built_in">camera</span>(</span><br><span class="line">+            <span class="keyword">double</span> vfov, <span class="comment">// top to bottom, in degrees</span></span><br><span class="line">+            <span class="keyword">double</span> aspect</span><br><span class="line">+        ) &#123;</span><br><span class="line">+            origin = <span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">+            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">+            <span class="keyword">auto</span> half_height = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">+            <span class="keyword">auto</span> half_width = aspect * half_height;</span><br><span class="line">+</span><br><span class="line">+            lower_left_corner = <span class="built_in">vec3</span>(-half_width, -half_height, <span class="number">-1.0</span>);</span><br><span class="line">+</span><br><span class="line">+            horizontal = <span class="built_in">vec3</span>(<span class="number">2</span>*half_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">+            vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">2</span>*half_height, <span class="number">0.0</span>);</span><br><span class="line">+        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 origin;</span><br><span class="line">        vec3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们使用一个<code>cam(90, double(image_width)/image_height)</code>的摄像机去拍下面的球:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> R = <span class="built_in">cos</span>(pi/<span class="number">4</span>);</span><br><span class="line">hittable_list world;</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(-R,<span class="number">0</span>,<span class="number">-1</span>), R, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))));</span><br><span class="line">world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>( R,<span class="number">0</span>,<span class="number">-1</span>), R, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))));</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="https://raytracing.github.io/images/img.wide-view.png" alt="一个90°广角镜头"></p>
<p>为了能将我们的摄像机设置在任意位置, 我们先来给这个位置点起个名字。我们管摄像机所在的这个位置叫做 <code>lookfrom</code> , 我们看向的点叫做<code>lookat</code>(如果你不想用世界坐标下的点, 想用向量来表示这个方向的话也完全ok)。</p>
<p>我们还需要一个变量去描述摄像机的倾斜程度, 或者说摄像机绕着轴<code>lookfrom - lookat</code>旋转的角度【想象下图中红色平面绕这个轴旋转】。就好比你站直了, 但是你的头还是可以左右转动。为了去描述这个倾斜程度, 我们需要一个向量来指定摄像机坐标系的正上方方向(up vector)。这里注意:这个向量就在视线方向正交投影过来的那个平面上:</p>
<p><img src="https://raytracing.github.io/images/fig.cam-look.jpg" alt="摄像机的视线方向"></p>
<p>我们可以使用任意的方向向量, 将其投影到上图的平面中来获得摄像机的up vector。我这里给他起名叫vup向量。经过一系列的点乘操作, 我们会有完整的u,v,w三个向量来描述摄像机的旋向【这里要结合着代码看与下面的图片看】。</p>
<p><img src="https://raytracing.github.io/images/fig.cam-up.jpg" alt="vup"></p>
<p>注意<code>vup</code>,<code>v</code>,<code>w</code>处于同一平面内。和先前我们的摄像机面对着-Z方向一样, 修改后的任意视角摄像机面对着-w方向。记得使用世界坐标系的上方向向量(0,1,0)(不是一定要用这个向量)指定vup。这样会比较方便, 并且你的摄像机镜头会保持水平。如果你想试试那些奇怪的摄像角度, 你可以放心大胆的传入别的值。</p>
<figure class="highlight c++"><figcaption><span>camera.h diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">+            vec3 lookfrom, vec3 lookat, vec3 vup,</span><br><span class="line">            <span class="keyword">double</span> vfov, <span class="comment">// top to bottom, in degrees</span></span><br><span class="line">            <span class="keyword">double</span> aspect</span><br><span class="line">        ) &#123;</span><br><span class="line">+            origin = lookfrom;</span><br><span class="line">            vec3 u, v, w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> half_height = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> half_width = aspect * half_height;</span><br><span class="line">+            w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">+            u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">+            v = <span class="built_in">cross</span>(w, u);</span><br><span class="line"></span><br><span class="line">+            lower_left_corner = origin - half_width*u - half_height*v - w;</span><br><span class="line"></span><br><span class="line">+            horizontal = <span class="number">2</span>*half_width*u;</span><br><span class="line">+            vertical = <span class="number">2</span>*half_height*v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + s*horizontal + t*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 origin;</span><br><span class="line">        vec3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以改变我们的视角了:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="built_in"><span class="keyword">double</span></span>(image_width) / image_height;</span><br><span class="line">...</span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(vec3(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">1</span>), vec3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), vup, <span class="number">90</span>, aspect_ratio)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="https://raytracing.github.io/images/img.view-distant.png" alt="从远处看"></p>
<p>然后我们在改变一下fov:【这里缩小了fov】</p>
<p><img src="https://raytracing.github.io/images/img.view-zoom.png" alt="放大看"></p>
<p><a id="defocus"></a></p>
<h2 id="12-散焦模糊"><a href="#12-散焦模糊" class="headerlink" title="12. 散焦模糊"></a>12. 散焦模糊</h2><p>终于到了我们最后的特性了: 散焦模糊(defocus blur)。基本上所有的摄影师都它叫景深(depth of field)。所以你和你朋友聊天的时候可别提什么defocus blur啊。</p>
<p>现实世界中的摄像机产生对焦模糊的原因是因为他们需要一个很大的孔, 而不是一个针眼大小的小孔来聚集光线。这会导致所有的东西都被散焦了。但如果我们在孔内加入一块透镜, 在一段距离内的所有物体都会被对焦。你可以这样来想象透镜:所有的光线从同一点分散射出, 击中透镜后又聚焦在图像传感器上的一个点上。</p>
<p>在现实世界的相机中, 物体在哪里被聚焦是由透镜距离成像平面与聚焦平面这两个平面的距离所决定的。当你改变对焦设置时,相机中的这个透镜位置就会发生改变(你手机上的摄像头也是这个原理, 只不过透镜不动, 改成了成像传感器动)。快门光圈(aperture)是一个孔, 它控制这块透镜应该多大比较好。如果你需要更多的光线, 你的这个快门光圈就大一点, 景深也会随之加大。对于一个虚拟的摄像机来说, 我们只需要一个传感器就够了。所以我们只需要传入快门光圈的大小就行【即透镜大小】。</p>
<p>现实世界中的摄像机的透镜组是很复杂的。但对于我们写代码来说, 我们只需要模拟上述的顺序: 图像传感器, 透镜, 快门, 然后射出光线, 最后记得翻转图片(进过透镜成像会被上下翻转)。图形学中人们常常使用一块薄片透镜近似模拟:</p>
<p><img src="https://raytracing.github.io/images/fig.cam-lens.jpg" alt="摄像机透镜模型"></p>
<p>但是我们根本不用模拟任何摄像机内部的东西, 对于我们渲染摄像机外的物体来说, 这些都没必要。我们只要从一个虚拟的透镜范围中发射光线到我们的摄像机平面就能模拟了,这个透镜与平面的距离成为焦距(focus_dist)</p>
<p><img src="https://raytracing.github.io/images/fig.cam-film-plane.jpg" alt="摄像机平面"></p>
<p>之前我们所有的光线都是从<code>lookfrom</code>发出的, 但现在加入了散焦模糊, 所有光线都从内部的一个虚拟透镜发出, 经过<code>lookfrom</code>点, 这个透镜的半径越大, 图像就越模糊。你可以认为之前的摄像机, 这个半径为0。</p>
<figure class="highlight c++"><figcaption><span>vec3.h 从一个单位小圆盘射出光线</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>,<span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>,<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出完整的camera类</p>
<figure class="highlight c++"><figcaption><span>camera.h diff</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">camera</span>(</span><br><span class="line">            vec3 lookfrom, vec3 lookat, vec3 vup,</span><br><span class="line">            <span class="keyword">double</span> vfov, <span class="comment">// top to bottom, in degrees</span></span><br><span class="line">+            <span class="keyword">double</span> aspect, <span class="keyword">double</span> aperture, <span class="keyword">double</span> focus_dist</span><br><span class="line">+        ) &#123;</span><br><span class="line">+            origin = lookfrom;</span><br><span class="line">+            lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">            <span class="keyword">auto</span> half_height = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> half_width = aspect * half_height;</span><br><span class="line"></span><br><span class="line">            w = <span class="built_in">unit_vector</span>(lookfrom - lookat);</span><br><span class="line">            u = <span class="built_in">unit_vector</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">            v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">+            lower_left_corner = origin</span><br><span class="line">+                              - half_width * focus_dist * u</span><br><span class="line">+                              - half_height * focus_dist * v</span><br><span class="line">+                              - focus_dist * w;</span><br><span class="line"></span><br><span class="line">+            horizontal = <span class="number">2</span>*half_width*focus_dist*u;</span><br><span class="line">+            vertical = <span class="number">2</span>*half_height*focus_dist*v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">+            vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">+            vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">+            <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">+                origin + offset,</span><br><span class="line">+                lower_left_corner + s*horizontal + t*vertical - origin - offset</span><br><span class="line">+           );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3 origin;</span><br><span class="line">        vec3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">+        vec3 u, v, w;</span><br><span class="line">+        <span class="keyword">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用一个大大的快门光圈:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="built_in"><span class="keyword">double</span></span>(image_width) / image_height;</span><br><span class="line">...</span><br><span class="line"><span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom-lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>

<p>就有:</p>
<p><img src="https://raytracing.github.io/images/img.depth-of-field.png" alt="加入景深效果"></p>
<p><a id="next"></a></p>
<h2 id="13-接下来学什么"><a href="#13-接下来学什么" class="headerlink" title="13. 接下来学什么?"></a>13. 接下来学什么?</h2><p>首先我们把书的封面图——许多许多的随机球渲染出来:</p>
<figure class="highlight c++"><figcaption><span>main.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">vec3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*random_double())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">vec3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = vec3::<span class="built_in">random</span>() * vec3::<span class="built_in">random</span>();</span><br><span class="line">                    world.<span class="built_in">add</span>(</span><br><span class="line">                        make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, make_shared&lt;lambertian&gt;(albedo)));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = vec3::<span class="built_in">random</span>(<span class="number">.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(</span><br><span class="line">                        make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, make_shared&lt;metal&gt;(albedo, fuzz)));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, make_shared&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    world.<span class="built_in">add</span>(make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, make_shared&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line"></span><br><span class="line">    world.<span class="built_in">add</span>(</span><br><span class="line">        make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, make_shared&lt;lambertian&gt;(<span class="built_in">vec3</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>))));</span><br><span class="line"></span><br><span class="line">    world.<span class="built_in">add</span>(</span><br><span class="line">        make_shared&lt;sphere&gt;(<span class="built_in">vec3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, make_shared&lt;metal&gt;(<span class="built_in">vec3</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="https://raytracing.github.io/images/img.book1-final.jpg" alt="最终场景"></p>
<p>你可能会发现玻璃球没有阴影, 使得他们看上去像漂浮在空中似得。这不是bug(你在现实世界中很少有机会见到真正的玻璃球, 它们看起来的确就是这样的)。玻璃球下的那个作为地板的大球仍然能被那么多光线击中, 玻璃球下的那个作为地板的大球仍然能被那么多光线击中, 因为光线并不会被玻璃球阻挡，经由玻璃球的折射最终射向天空。【the sky is re-ordered rather than blocked. 感谢评论区<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/iioo-95">Kanichiyaoba</a> 的翻译解答】</p>
<p>现在你拥有一个coooool毙了的光线追踪器了! 那接下来我该何去何从呢?【标*为<a target="_blank" rel="noopener" href="https://oxine.github.io/Graphic/Ray-tracing-the-next-week/">下本书</a>中的内容】</p>
<p>1.光照。你可以使用阴影光线来显式实现这部分, 也可以使用产生光线的材质来隐式实现*。</p>
<p>2.偏移散射光线, 然后降低这些光线的权重来消除偏移。这两种都行。硬要说的话, 我偏向后者一点点。【我猜这句话是在说消除自相交所导致的阴影 即Shadow Ance, 如果有人知道这是在说什么请教教我吧！】</p>
<p>3.加入三角形。大部分模型都是三角网格。模型的IO部分是最恶心的, 基本上所有人都不想自己写, 都去找别人的代码用。</p>
<p>4.表面纹理*。这可以让你像贴墙纸一样把图片贴到物体上去。实现起来也很简单。</p>
<p>5.固体纹理*。可以参见Ken Perlin的在线代码, Andrew Kensler的blog中也有关于这部分的信息。</p>
<p>6.体积体(volumes 即雾等)*与其他介质。很Cool, 但是会改变你的代码构筑。我喜欢把体积体也设计成hittable的子类, 根据其密度来随机决定光线是否与其相交。使用这个方法, 你的渲染器甚至不用知道你渲的是体积体就渲出来了。</p>
<p>7.并行优化。使用不同的随机种子, 把你的代码复制上$N$份跑在$N$个核心上,然后再求平均值。你可以分层来完成这部分工作, 比如分成$N/2$对, 每次平均求出$N/4$【为什么是N/4啊？？这翻译翻不下去了！】的图片, 然后在对这些对之间求平均值。这应该用不了多少代码【试试CUDA吧】。</p>
<p>记得把你渲染出的炫酷图片发给我!祝你愉快!</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>ray tracing in one weekend 中文翻译</p><p><a href="https://matrix4f.com/Graphic/ray-tracing-in-one-weekend/">https://matrix4f.com/Graphic/ray-tracing-in-one-weekend/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>oxine</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-03-03</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-06-11</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/ray-tracing/">ray tracing</a><a class="link-muted mr-2" rel="tag" href="/tags/graphic/">graphic</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5e575f43dd6a4d00131154ef&amp;product=image-share-buttons&amp;cms=sop" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Graphic/Ray-tracing-the-next-week/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Ray tracing the next week 中文翻译</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Graphic/ray-tracing-in-one-weekend-explanation/"><span class="level-item">Ray tracing in one weekend 疑难点解析与拓展</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><h3 class="title is-7" style="color:darkcyan;">昵称处填入QQ号，自动同步QQ头像与ID</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "xFlGOP7pYlFpDY3wlCO27zMz-gzGzoHsz",
            appKey: "muTfaJQhwshHbyBARiuoF2NQ",
            
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            recordIP: true,
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Oxine"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Oxine</p><p class="is-size-6 is-block">Student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/oxine" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/oxine"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="https://i.loli.net/2020/03/22/znt5elO6bspQrgN.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=956898372&amp;website=www.oicqzone.com"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Steam" href="https://steamcommunity.com/id/oxine/"><i class="fab fa-steam-square"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">1. 概述</span></span></a></li><li><a class="level is-mobile" href="#2-输出你的图像"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. 输出你的图像</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-加入进度提示"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1. 加入进度提示</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-vec3向量类"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. vec3向量类</span></span></a></li><li><a class="level is-mobile" href="#4-光线-简单摄像机-以及背景"><span class="level-left"><span class="level-item">4</span><span class="level-item">4. 光线, 简单摄像机, 以及背景</span></span></a></li><li><a class="level is-mobile" href="#5-加入球体"><span class="level-left"><span class="level-item">5</span><span class="level-item">5. 加入球体</span></span></a></li><li><a class="level is-mobile" href="#6-面法相与复数物体"><span class="level-left"><span class="level-item">6</span><span class="level-item">6. 面法相与复数物体</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-一些C-的新特性"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">6.1. 一些C++的新特性</span></span></a></li><li><a class="level is-mobile" href="#6-2-常用的常数与工具函数"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">6.2. 常用的常数与工具函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-反走样-抗锯齿"><span class="level-left"><span class="level-item">7</span><span class="level-item">7. 反走样(抗锯齿)</span></span></a></li><li><a class="level is-mobile" href="#8-漫反射材质"><span class="level-left"><span class="level-item">8</span><span class="level-item">8. 漫反射材质</span></span></a></li><li><a class="level is-mobile" href="#9-金属材质"><span class="level-left"><span class="level-item">9</span><span class="level-item">9. 金属材质</span></span></a></li><li><a class="level is-mobile" href="#10-绝缘体材质"><span class="level-left"><span class="level-item">10</span><span class="level-item">10. 绝缘体材质</span></span></a></li><li><a class="level is-mobile" href="#11-可自定义位置的摄像机"><span class="level-left"><span class="level-item">11</span><span class="level-item">11. 可自定义位置的摄像机</span></span></a></li><li><a class="level is-mobile" href="#12-散焦模糊"><span class="level-left"><span class="level-item">12</span><span class="level-item">12. 散焦模糊</span></span></a></li><li><a class="level is-mobile" href="#13-接下来学什么"><span class="level-left"><span class="level-item">13</span><span class="level-item">13. 接下来学什么?</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/oxine" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MyGithub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="http://www.cplusplus.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">cpp reference</span></span><span class="level-right"><span class="level-item tag">www.cplusplus.com</span></span></a></li><li><a class="level is-mobile" href="https://www.shadertoy.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ShaderToy</span></span><span class="level-right"><span class="level-item tag">www.shadertoy.com</span></span></a></li><li><a class="level is-mobile" href="http://www.realtimerendering.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">RTR</span></span><span class="level-right"><span class="level-item tag">www.realtimerendering.com</span></span></a></li><li><a class="level is-mobile" href="https://www.pbr-book.org/3ed-2018/contents" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">PBRT</span></span><span class="level-right"><span class="level-item tag">www.pbr-book.org</span></span></a></li><li><a class="level is-mobile" href="https://kesen.realtimerendering.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Siggraph paper</span></span><span class="level-right"><span class="level-item tag">kesen.realtimerendering.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Graphic/"><span class="level-start"><span class="level-item">Graphic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math/Geometry/"><span class="level-start"><span class="level-item">Geometry</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/closestpoint/"><span class="tag">closestpoint</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/graphic/"><span class="tag">graphic</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/highlight-js/"><span class="tag">highlight.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intersection/"><span class="tag">intersection</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ipv6/"><span class="tag">ipv6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/math/"><span class="tag">math</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ray-tracing/"><span class="tag">ray tracing</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssl/"><span class="tag">ssl</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-07T15:14:59.000Z">2020-11-07</time></p><p class="title"><a href="/Network/self-sign/">当我们自签名时，我们其实是在做什么</a></p><p class="categories"><a href="/categories/Network/">Network</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-06T08:34:44.000Z">2020-11-06</time></p><p class="title"><a href="/Network/aliyun-ipv6/">使阿里云服务器支持ipv6</a></p><p class="categories"><a href="/categories/Network/">Network</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-24T05:08:40.000Z">2020-04-24</time></p><p class="title"><a href="/Math/rotate-by-arbitrary-line/">绕任意轴旋转, 绕任意直线旋转矩阵推导</a></p><p class="categories"><a href="/categories/Math/">Math</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-21T01:18:01.000Z">2020-04-21</time></p><p class="title"><a href="/Math/projection-matrix/">投影矩阵之十万个为什么</a></p><p class="categories"><a href="/categories/Math/">Math</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-28T14:46:32.000Z">2020-03-28</time></p><p class="title"><a href="/Math/Geometry/closest-point-on-line/">点到直线最短距离</a></p><p class="categories"><a href="/categories/Math/">Math</a> / <a href="/categories/Math/Geometry/">Geometry</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Oxine&#039;s site" height="28"></a><p class="is-size-7"><span>&copy; 2021 oxine</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>